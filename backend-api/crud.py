from sqlalchemy.orm import Session
import schema, models
from sqlalchemy import func
from fastapi import HTTPException
#from rabbitmq import publish_book_update  # Import the function
from rabbitmq import publish_message


# Function to add a book and notify the frontend API
def add_book(db: Session, book: schema.BookCreate):
    # Create and add the book
    db_book = models.Book(
        title=book.title,
        publisher=book.publisher,
        category=book.category
        
    )
    db.add(db_book)
    db.commit()
    db.refresh(db_book)  # This will refresh db_book and get the auto-generated id

    # Publish the book data to RabbitMQ
    book_message = {
        "id": db_book.id,  # Now we can use db_book.id, which is generated by the backend
        "title": db_book.title,
        "publisher": db_book.publisher,
        "category": db_book.category,
        "available": db_book.available
    }
    publish_message(book_message)  # Send the book data to RabbitMQ

    return db_book

# Remove Book from Catalogue
def delete_book(db: Session, book_id: int):
    # Query the user to delete
    db_book = db.query(models.Book).filter(models.Book.id == book_id).first()
    
    if db_book:
        # Delete the book
        db.delete(db_book)
        db.commit()
        return {"message": "Book deleted successfully"}
    else:
        # Handle case where book is not found
        return {"error": "Book not found"}
    
# # CRUD function to delete a book
# def delete_book(db: Session, book: models.Book):
#     db.delete(book)
#     db.commit()


# Get all users
def get_users(db: Session, offset: int = 0, limit: int = 10):
    return db.query(models.User).offset(offset).limit(limit).all()

# List users and the books they have borrowed
def get_users_with_borrowed_books(db: Session, offset: int = 0, limit: int = 10):
    return db.query(models.User).offset(offset).limit(limit).all()

# Fetch all unavailable books with return dates
def get_unavailable_books(db: Session):
    unavailable_books = db.query(models.Book).filter(models.Book.available == False).all()
    
    # Return a list of schema.BookUnavailable objects
    return [
        schema.BookUnavailable(
            id=book.id,
            title=book.title,
            publisher=book.publisher,
            category=book.category,
            return_date=book.return_date  # Return the date when the book will be available
        ) for book in unavailable_books
    ]


# Get all books
def get_books(db: Session, offset: int = 0, limit: int = 10):
    return db.query(models.Book).offset(offset).limit(limit).all()


# Create User in the backend database
def create_user(db: Session, user: schema.UserCreate):
    db_user = models.User(
        email=user.email,
        first_name=user.first_name,
        last_name=user.last_name
    )
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    return db_user

